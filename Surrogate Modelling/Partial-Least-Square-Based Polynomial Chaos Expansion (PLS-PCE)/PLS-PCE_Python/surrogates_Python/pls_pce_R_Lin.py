"""
---------------------------------------------------------------------------
PCE-driven PLS algorithm - Linear version
---------------------------------------------------------------------------
Created by:
Fong-Lin Wu (fonglin.wu@tum.de)
Max Ehre (max.ehre@tum.de)
Technische Universitat Munchen
www.era.bgu.tum.de
---------------------------------------------------------------------------
Version: 
* 2019-08 Transition from Matlab
---------------------------------------------------------------------------
Input:
* X      : Design input generated by Latin-Hypercube
* Y      : Result from Finite-Element-Method
* d      : Maximum number of components (directions)
* pmax   : Maximum polynomial order of PCE-PLS
---------------------------------------------------------------------------
Output:
* f      : Lamda function of PCE-PLS model
* Yhat   : Result outpur by PCE-PLS model
* orthogonal_error: Orthogonal error
* d_red  : Number of used PCE directions 
* pfinal : Final order of polynomial chaos expansion
---------------------------------------------------------------------------
Based on: 
* PLS-based adaptation for efficient PCE representation in high dimensions.
Iason Papaioannou ∗, Max Ehre, Daniel Straub
Engineering Risk Analysis Group, Technische Universität München, Arcisstr. 21, 80290 München, Germany
---------------------------------------------------------------------------
"""

import numpy as np

# Make sure having these scripts under the same workspace
from pce_poly import pce_poly   # kernel for computing coefficients of PCE

def pls_pce_R(X,Y,d,pmax):

    # PCE-driven PLS with 1-D PCE evaluation
    n = np.size(X,0)    # number of points
    m = np.size(X,1)    # original problem dimension

    # center matrices
    meanX   = np.mean(X,0)
    meanY   = np.mean(Y,0)
    X0      = X - meanX
    Y0      = Y - meanY

    Wload   = np.zeros((m,d))
    Pload   = np.zeros((m,d))
    Yvar    = np.zeros((d,1))
    Xscore  = np.zeros((n,d))
    Freg    = np.zeros((np.size(Y),1))

    pfinal  = np.zeros(pmax)
    g_pce1  = [0]*d
    aout    = [0]*d
    a       = [0]*pmax

    E = X0
    F = Y0

    for i in range(d):
        
        # compute normalized weight
        Wload0 = ( E.T @ F )
        alpha  = np.linalg.norm(Wload0)
        Wload0 = Wload0 / alpha

        # compute score
        Xscore0 =  E @ Wload0

        # we assume linear responses
        Wload[:,i] = Wload0.flatten()         
        Xscore[:,i] = Xscore0.flatten()
        pfinal[i] = 1

        # fit a 1-D PCE
        [g_pce1[i], Freg, a, _, _] = pce_poly( Xscore[:,i].reshape(n,-1), F, int(pfinal[i]) )
        
        aout[i] = a      
        Yvar[i] = np.var(Freg) / np.var(Y0)      
        Pload[:,i] = (Xscore[:,i].reshape(-1,1)).T @ E / np.dot(Xscore[:,i],Xscore[:,i]) 
        
        if Yvar[i] / sum(Yvar) < 0.005:
            break
        
        E = E - Xscore[:,i].reshape(-1,1) @ (Pload[:,i].reshape(-1,1)).T
        F = F - Freg.reshape(F.shape) 
        
    i    = i + 1    
    d_red = i

    Wload   = Wload[:,0:d_red]
    Pload   = Pload[:,0:d_red]
    Xscore  = Xscore[:,0:d_red]
    Yvar    = Yvar[0:d_red]

    R = Wload @ np.linalg.pinv(np.transpose(Pload) @ Wload)

    orthogonal_error = np.eye(i) - np.transpose(R) @ R

    f    = lambda X: meanY + np.sum( [ g_pce1[index]( ((X - meanX)@R[:,index]).reshape(-1,1) ) for index in range(i)] , 0)
    Yhat = f(X).reshape(n,-1)

    return f, Yhat, orthogonal_error, d_red, pfinal