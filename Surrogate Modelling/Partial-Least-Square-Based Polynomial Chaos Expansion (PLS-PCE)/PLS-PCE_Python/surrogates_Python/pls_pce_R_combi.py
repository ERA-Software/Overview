"""
---------------------------------------------------------------------------
PCE-driven PLS algorithm
---------------------------------------------------------------------------
Created by:
Fong-Lin Wu (fonglin.wu@tum.de)
Max Ehre (max.ehre@tum.de)
Technische Universitat Munchen
www.era.bgu.tum.de
---------------------------------------------------------------------------
Version: 
* 2019-08 Transition from Matlab
---------------------------------------------------------------------------
Input:
* X      : Design input generated by Latin-Hypercube
* Y      : Result from Finite-Element-Method
* d      : Maximum number of components (directions)
* pmax   : Maximum polynomial order of PCE-PLS
---------------------------------------------------------------------------
Output:
* f      : Lamda function of PCE-PLS model
* Yhat   : Result outpur by PCE-PLS model
* orthogonal_error: Orthogonal error of R matrix
* d_red  : Number of used PCE directions 
* pfinal : Final order of polynomial chaos expansion
---------------------------------------------------------------------------
Based on: 
* PLS-based adaptation for efficient PCE representation in high dimensions.
Iason Papaioannou ∗, Max Ehre, Daniel Straub
Engineering Risk Analysis Group, Technische Universität München, Arcisstr. 21, 80290 München, Germany
---------------------------------------------------------------------------
"""

import numpy as np
from numpy.matlib import repmat

# Make sure having these scripts under the same workspace
from pce_poly import pce_poly   # kernel for computing coefficients of PCE

def pls_pce_R(X,Y,d,pmax):

    # PCE-driven PLS with 1-D PCE evaluation
    n = np.size(X,0)    # number of points
    m = np.size(X,1)    # original problem dimension

    tol     = 1.e-3
    maxiter = 100

    # center matrices
    meanX   = np.mean(X,0)
    meanY   = np.mean(Y,0)
    X0      = X - meanX
    Y0      = Y - meanY

    Wload   = np.zeros((m,d))
    Pload   = np.zeros((m,d))
    Yvar    = np.zeros((d,1))
    Xscore  = np.zeros((n,d))
    Xscorep = np.zeros((n,d))
    Freg    = np.zeros((np.size(Y),1))
    
    g_pcep  = [0]*pmax
    Fregp   = [0]*pmax
    Q2      = np.zeros(pmax)

    pfinal  = np.zeros(d)
    g_pce1  = [0]*d
    aout    = [0]*d
    a       = [0]*d

    E = X0
    F = Y0

    for i in range(d):
        
        # compute normalized weight
        Wload0 = ( E.T @ F )
        alpha  = np.linalg.norm(Wload0)
        Wload0 = Wload0 / alpha

        # compute score
        Xscore0 =  E @ Wload0
        
        Wloadp = np.zeros((len(Wload0), pmax))
        
        # we assume non-linear response in the first 3 steps
        if i < 3:
           
            # try with different order PCE
            for p in range(pmax):                        
                
                Wloadp[:,p] = Wload0.flatten()
                Xscorep0 = Xscore0
                
                for iter in range(maxiter):
                    
                    # fit 1D PCE
                    [_,Freg,a[p],Psi,_] = pce_poly(Xscorep0.reshape(n,-1), F, p)
                    
                    err = F - Freg
                    
                    Z =  np.multiply( E , repmat( Psi[:,0:p+1] @ ( np.multiply( a[p][1:p+2], np.sqrt(( np.arange(1,p+2) )).reshape(-1,1) ) ), 1, m) ) 
                        
                    # Newton-Ralphson linearization
                    dW = (np.linalg.pinv( Z.T @ Z ) @ Z.T @ err).flatten()
                    # flatten it to follow the broadcast rule of np array

                    Wloadp[:,p] = Wloadp[:,p] + dW
                    Wloadp[:,p] = Wloadp[:,p] / np.linalg.norm(Wloadp[:,p])
                    Xscorep1 = E @ Wloadp[:,p]
                    
                    dXscorep = np.linalg.norm(Xscorep1.reshape(n,-1)-Xscorep0.reshape(n,-1)) / np.linalg.norm(Xscorep0)
                    
                    if dXscorep < tol:
                        Xscorep[:,p] = Xscorep1
                        break
                    else:
                        Xscorep0 = Xscorep1
                    
                if iter == maxiter:
                    # maximum iterations reached: use pls direction
                    Wloadp[:,p] = Wload0
                    Xscorep[:,p] = Xscore0

                [g_pcep[p], Fregp[p], a[p], Psi, Q2[p]] = pce_poly(Xscorep0.reshape(n,-1), F,  p)
                
                if Q2[p] > 1-1.e-4:
                    break
            
            # choose the one with lowest leave-one-out error
            pfinal[i] = np.argwhere( Q2 == np.max(Q2[0:p+1]) ) 
            
            if type(pfinal) != list:    #transform into int list for indexing
                pfinal = pfinal.tolist()
            pfinal = [ int(x) for x in pfinal ]
            
            # assign final result to current the direction 
            Wload[:,i] = Wloadp[:,pfinal[i]]
            Xscore[:,i] = Xscorep[:,pfinal[i]]
            Freg = Fregp[pfinal[i]]        
            g_pce1[i] = g_pcep[pfinal[i]]
            aout[i]   = a[pfinal[i]]

        # we assume linear response after first 3 directions
        else:
            Wload[:,i] = Wload0.flatten()         
            Xscore[:,i] = Xscore0.flatten()
            pfinal[i] = 1
            [g_pce1[i], Freg, a, Psi, _] = pce_poly( Xscore[:,i], F, pfinal[i])
            
            aout[i] = a
        
        Yvar[i] = np.var(Freg) / np.var(Y0)        
        Pload[:,i] = (Xscore[:,i].reshape(-1,1)).T @ E / np.dot(Xscore[:,i],Xscore[:,i])  
        
        if Yvar[i] / sum(Yvar) < 0.005:
            break
        
        E = E - Xscore[:,i].reshape(-1,1) @ (Pload[:,i].reshape(-1,1)).T
        F = F - Freg.reshape(F.shape) 
        
    i    = i + 1    
    d_red = i

    Wload   = Wload[:,0:d_red]
    Pload   = Pload[:,0:d_red]
    Xscore  = Xscore[:,0:d_red]
    Yvar    = Yvar[0:d_red]

    R = Wload @ np.linalg.pinv(np.transpose(Pload) @ Wload)

    orthogonal_error = np.eye(i) - np.transpose(R) @ R

    f    = lambda X: meanY + np.sum( [ g_pce1[index]( ((X - meanX)@R[:,index]).reshape(-1,1) ) for index in range(i)] , 0)
    Yhat = f(X).reshape(n,-1)

    return f, Yhat, orthogonal_error, d_red, pfinal